#!/bin/bash

  # Fallback $DISPLAY variable to :0.
if [ -z $DISPLAY ]; then export DISPLAY=':0'; fi

_name="$(basename $0)"
_scriptRoot="$(dirname $(realpath $0))"
_configFile="$_scriptRoot/$(basename $0).conf"
_dbFile="$_scriptRoot/$(basename $0).db"
_dbTable="$(basename $0)"


declare -A _dbStructure

_dbStructure[path]='varchar(255)'
_dbStructure[res]='varchar(255)'
_dbStructure[profile]='varchar(6)'
_dbStructure[checksum]='varchar(40)'
_dbUnique='UNIQUE(path)'

#     _                
#  __| | ___ _ __  ___ 
# / _` |/ _ \ '_ \/ __|
#| (_| |  __/ |_) \__ \
# \__,_|\___| .__/|___/
#           |_|        

for dependency in awk date dirname feh find grep identify logger xrandr
do
  which $dependency >/dev/null 2>&1 || missing="$missing $dependency "
done
if [[ ! -z "$missing" ]]
then
  echo -ne "Couldn't find these programs:$missing\nPlease install the relevant packages or check your \$PATH."
  exit 1
fi



# _____                 _   _                 
#|  ___|   _ _ __   ___| |_(_) ___  _ __  ___ 
#| |_ | | | | '_ \ / __| __| |/ _ \| '_ \/ __|
#|  _|| |_| | | | | (__| |_| | (_) | | | \__ \
#|_|   \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
#


function log {
  if [ -t 1 ]; then logcommand="echo -e"; else logcommand=logger && prefix="$_name - "; fi # use echo if stdout is a terminal

  if [ "$DEBUG" == "1" ] && [[ "$1" =~ "DEBUG" ]]
  then
    echo -e "${prefix}${@}"
    logger "$(echo -e "${prefix}${@}")"
  elif [[ ! "$1" =~ "DEBUG" ]]
  then
    $logcommand "${prefix}${@}"
  fi
}

function readConfig {
  #Generate the config if missing or asked
if [ ! -f $_configFile ] || [ "$1" == 'recreate' ]
then
  cat > $_configFile << EOF
# This conf can be deleted at any time for a regenerated default copy.

WPDirectory="\$HOME/Wallpapers/"
WPRecursion="no"

  # Fill or Scale images?
bgmode=fill
#bgmode=scale

  # Try for native res?
tryNativeRes=yes
  # Try for spannable wallpapers? (Multi monitor)
trySpanWallpapers=yes

  # Percentage chance for span? (If both set to yes)
spanWallpaperPercentChance=10

  # Regenerate the DB if older than this many seconds
dbStaleTime="86400" # A day
EOF
fi
if [ "$1" == 'recreate' ] ; then exit ; fi
    # Sets vars from config, quits if they're not found.
  _wantedVars="$@" #What we search for

  for configOption in $_wantedVars
   do
      #If not found, warn and die
      if var=$(grep -E "^$configOption=.+$" $_configFile)
      then
        eval $var #Set it
      else
        echo "Cannot find var :$configOption: in $_configFile. Regenerating the config file for next run." ; readConfig recreate
        exit 1
      fi
  done
}

function showDb {
  if [ -f "$_dbFile" ]
  then
    log "Showing current DB contents then exiting"
    queryDb "select * from $_dbTable;" | sed 's/|/\t/g'
  else
    log "DB file not found ($_dbFile), one must be generated first."
  fi
  exit 0
}

function genDb {

  log "Working on database. One moment.."

  for column in ${!_dbStructure[@]}
  do
    tableQuery+=$(echo -n "$column ${_dbStructure[$column]}, ")
  done

  tableQuery+="$_dbUnique"

    # Always start by trying to create the table in case missing or brand new db.
  queryDb "CREATE TABLE if not exists $_dbTable ( $tableQuery );"
  touch "$_dbFile"

    # Get all existing db column info.
  declare -A existingTables
  while read columnInfo 
  do
    columnName=$(cut -d'|' -f2 <<< $columnInfo)
    columnType=$(cut -d'|' -f3 <<< $columnInfo)
    existingTables[$columnName]="$columnType"
  done <<< $(queryDb "PRAGMA table_info($_dbTable);")

   # Compare existing db columns with what we expect and add them if missing.
   # Sort of like a rolling db upgrade with new versions of this script.
  for expectedColumn in ${!_dbStructure[@]}
  do
    if [[ "${_dbStructure[$expectedColumn]}" != "${existingTables[$expectedColumn]}" ]] # Quick hack check if it's there plus the correct datatype.
    then
        # If column missing, add it. If present but wrong, drop first.
      if [ ! -z "${existingTables[$expectedColumn]}" ] 
      then
        log "Database column :$expectedColumn: incorrect or old datatype. Recreating it for future."
        queryDb "alter table $_dbTable drop $expectedColumn"
      else
        log "Database column :$expectedColumn: missing. Adding now for future reindexing."
      fi

      queryDb "alter table $_dbTable add $expectedColumn ${_dbStructure[$expectedColumn]}"
    fi 
  done

    # Disable recursion if 'no' specified.
  set -o noglob
  if [ "$WPRecursion" == "no" ]
  then
    recursionFlags="-maxdepth 1"
  elif [ "$WPRecursion" == "yes" ]
  then
    recursionFlags="-not -path *disabled*"
  fi

    # Find, identify dimensions and format findings as INSERT queries.
  allWallpapers="$(find "${WPDirectory}" ${recursionFlags} -type f)"
  allCount=$(wc -l <<< $allWallpapers)

  log "Indexing now. $allCount images found in $WPDirectory."
  
    # Note down all wallpapers we already know about.
  while read existingImage
  do
    existingImages+=("$existingImage")
  done <<< "$(queryDb "select path from $_dbTable")"

  echo "${#existingImages[@]} existing images indexed."

  while read wallpaperFile
  do
      unset checksum ; checksum=$(sha1sum "$wallpaperFile" | awk '{ print $1 }')

      # Check if we've already scanned this one before building an insert query for it.
    pathCheckresult="$(queryDb "select path from $_dbTable where path = '$wallpaperFile';" | wc -l)"
    if [ $pathCheckresult -gt 0 ]
    then
      checksumCheckresult=$(queryDb "select checksum from $_dbTable where path = '$wallpaperFile' and checksum = '$checksum';" | wc -l)
      if [ $checksumCheckresult -gt 0 ]
      then
        log "DEBUG: Checksum still matches, skipping: $wallpaperFile."
        continue
      fi
    fi

    if [ ! -z "$DEBUG" ] ; then (((index++))) ; echo $index ; fi

    wallpaperDims="$(identify -format '%wx%h' "$wallpaperFile")"
    colorProfile="$(magick "$wallpaperFile" -resize 1x1\! -resize 1x1 txt:-|grep -Eo '#([0-9]|[A-F]){6}')"
    sql+=("insert or replace into $_dbTable values('$wallpaperFile','$wallpaperDims','$colorProfile', '$checksum');")
    done <<< $allWallpapers


  for line in "${sql[@]}"
  do
    queryDb "$line"
  done
}

function dbPrep {
  if [ ! -f $_dbFile ]; then genDb; fi #If missing, generate.

  if [ "$(date -r $_dbFile +%s)" -lt "$(((`date +%s` - $dbStaleTime)))" ]
  then
    log "Database is over $dbStaleTime seconds old, regenerating to catch new changes"
    genDb #Regen the database
  fi
}

function queryDb {
  query="$1"
  if [ -f $_dbFile ] || [[ "$query" == *"CREATE"* ]]
  then
    sqlite3 "$_dbFile" "$query"
  else
    log "queryDb function: DB File not found. Path: $_dbFile"
    exit 1
  fi
}

function fetchRandomImages {

  readarray -t queryResults <<< $(queryDb "select path from $_dbTable where res = '$searchRes' order by random() limit $imageFetchCount;")

  if [ ${#queryResults[@]} -lt $imageFetchCount ] || [ -z "${queryResults[0]}" ] # Check total results aren't too short and first entry isn't blank.
  then
    log "DEBUG: Not enough $searchRes results for these monitors. Falling back and accepting any resolution wallpaper."
    searchRes=$primaryRes
    readarray -t queryResults <<< $(queryDb "select path from $_dbTable order by random() limit $totalMonitorCount;")
    if [ ${#queryResults[@]} -lt $imageFetchCount ]; then log "DEBUG: Couldn't find any enough images? Regenerating and exiting in panic" ; genDb ; exit 1; fi
  fi

  for imageIndex in ${!queryResults[@]} # Check if they exist
  do
    log "DEBUG: testing whether :${queryResults[imageIndex]}: exists."
    if [ ! -f "${queryResults[imageIndex]}" ]; then log "Db returned non-existent image file, regenerating database now and exiting." ;genDb; exit 1; fi
  done
  
  #echo ${queryResults[@]}
}

function setWallpaper {

  if [[ "$windowManager" == "Xfwm4" ]]
  then
    log "DEBUG: xfce4 environment detected"
    if [ "$searchRes" == "$combinedRes" ]
    then
	for i in $(seq 0 $((($totalMonitorCount - 1))))
	do
          xfconf-query -c xfce4-desktop -p /backdrop/screen0/monitor${monitorList[0]}/workspace0/image-style -s 6 # Spanning Screens mode
        done
          # Set a span wallpaper with xfconf if the right time
        xfconf-query -c xfce4-desktop -p "/backdrop/screen0/monitor${monitorList[0]}/workspace0/last-image" -s "${queryResults[0]}"
    else
        # Otherwise, set one for each monitor
        for i in $(seq 0 $((($totalMonitorCount - 1))))
        do
	  log "DEBUG: Setting ${monitorList[$i]}"
          if [[ "$bgmode" == "fill" ]]
          then
            xfconf-query -c xfce4-desktop -p /backdrop/screen0/monitor${monitorList[$i]}/workspace0/image-style -s 3 # Stretched
          elif [[ "$bgmode" == "scale" ]]
          then
            xfconf-query -c xfce4-desktop -p /backdrop/screen0/monitor${monitorList[$i]}/workspace0/image-style -s 4 # Scale
          fi

          xfconf-query -c xfce4-desktop -p "/backdrop/screen0/monitor${monitorList[$i]}/workspace0/last-image" -s "${queryResults[$i]}"
        done
    fi
  else

    # Use feh if no other supported window manager detected.
    log "DEBUG: No other supported environment detected, using feh."

    if [ "$searchRes" == "$combinedRes" ]
    then
        fehArguments="--bg-tile \"$queryResults\"" # --bg-tile works for multi-monitor wallpapers.
    else
      #fehArguments=$(while read chosenImage ; do echo -n "--bg-$bgmode" "\"$chosenImage\" " ;   done <<<"${queryResults[@]}")
      fehArguments=$(for imageIndex in ${!queryResults[@]}; do echo -n "--bg-$bgmode" "\"${queryResults[$imageIndex]}\" "; done)
    fi
    
      # Log what's been picked for later checking.
    log "$(date) Command: feh $fehArguments"

    eval feh $fehArguments 2>&1|head -n1
  fi

}

function help {
  echo "Set random backgrounds automatically from $HOME/Wallpapers (Or another configured directory!)"
  echo "Arguments for $0:"
  echo -e "\t-help\t\tOutputs help."
  echo -e "\t-regendb/-regen\tRegenerates the image database for your configured wallpaper dir."
  echo -e "\t-showdb\tSpits out every image entry in our current DB."
  echo -e "\t-debug\t\tMakes the script more talkative."
  exit 1
}


#    _                  
#   / \   _ __ __ _ ___ 
#  / _ \ | '__/ _\ / __|
# / ___ \| | | (_| \__ \
#/_/   \_\_|  \__, |___/
#             |___/     

while [ $# -gt 0 ]
do
  case "$(tr '[:upper:]' '[:lower:]'<<<$1)" in
    -showdb)
        SHOWDB="1"
    ;;
    -regendb|-regen)
        FORCEREGEN="1"
    ;;
     -debug)
        DEBUG="1"
    ;;
     help|-help)
        help
    ;;
     *) /bin/echo "Unknown argument $1"
        help
    ;;
    esac
    shift
done

# ____
#|  _ \ _   _ _ __
#| |_) | | | | '_ \
#|  _ <| |_| | | | |
#|_| \_\\__,_|_| |_|

readConfig "WPDirectory WPRecursion bgmode tryNativeRes trySpanWallpapers dbStaleTime spanWallpaperPercentChance"

  # Get current window manager
windowManager="$(wmctrl -m | grep -oP '(?<=Name: )(.*)')"

  # Determine active display count.
monitorList=($(xrandr --listactivemonitors | grep -oP '(?<=\ \ ).*' | tr '\n' ' '))
totalMonitorCount="$(wc -w <<< ${monitorList[@]})"

imageFetchCount="$totalMonitorCount"
combinedRes="$(xrandr |grep -Po '(?<=current\ )[0-9]+ x [0-9]+' | tr -d ' ')"
primaryRes="$(xrandr | grep \* | awk '{print $1}'|head -n1)"


  # Show current db but exit early afterwards.
if [ ! -z $SHOWDB ]; then showDb ; fi

  # Regen db if requested. Do regular stale check otherwise.
if [ ! -z $FORCEREGEN ]; then genDb ; else dbPrep ; fi


  # Select x random images from the db based on active displays or a single span bg.
if [ "$tryNativeRes" == 'yes' ] && [ "$trySpanWallpapers" == 'yes' ]
then
    #Diceroll for which we go with
  diceResult="$(($RANDOM % 100))"
  if [ $diceResult -le $spanWallpaperPercentChance ]
    then searchRes=$combinedRes && imageFetchCount=1
    else searchRes=$primaryRes
  fi

elif [ "$tryNativeRes" == 'yes' ]
then
  searchRes=$primaryRes

elif [ "$trySpanWallpapers" == 'yes' ]
then
  searchRes=$combinedRes 

fi

fetchRandomImages
log "DEBUG: queryResults = ${queryResults[@]}"


  setWallpaper
exit $?
